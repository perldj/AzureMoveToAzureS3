param
(
    [string]$dbServer = "",
    [string]$dbName = "",
    [string]$dbUser = "",
    [string]$dbPassword = "",
    [string]$createBucket = "",
    [string]$containername = "",
    [string]$bucketName = "",
    [string]$tables = "",
    [string]$isMinio = ""
)

function Move-DataToAWS([string]$tableName, [string]$primaryKeyColumnName, [string]$contentColumnName, [bool]$isIdColumnInt = $true) {
$hasResults = 1;
while ($hasResults -eq 1) {
    $totalItemsToImport = $msmDatabase.ExecuteWithResults("SELECT COUNT(*) as totalItems FROM $tableName WHERE externalStorageProvider like '%AzureBlob%';").Tables[0].totalItems
    $totalItems = 1000;
    if ($totalItems -gt 0) { 
        echo "Translating $tableName data to Azure storage..."
    } else {
        echo "Found no data to move in $tableName table"
        return
    }
    
    $progress = 0;
    $failedCount = 0;
    $successCount = 0;

    $results = $msmDatabase.ExecuteWithResults("SELECT TOP (1000) $primaryKeyColumnName AS id, $contentColumnName AS content FROM $tableName WHERE externalStorageProvider like '%{""Type"":""S3""%';")
    if ($results) {
    $results.Tables[0] | ForEach-Object {
        $id = $_.id
        $content = $_.content
        "Have content as $content"

        $jsonObject = ConvertFrom-Json $content
        

        "Mutating json object"
        $jsonObject.Type = "AzureBlob"
        $jsonObject.Region = ""
        $jsonObject.PSObject.Properties.Remove('Region')
        $bucketname = $jsonObject.BucketName
        $jsonObject.ServiceUrl = "https://$containername.core.windows.net/$bucketname"

        $newJsonString = $jsonObject | ConvertTo-Json

        "New mutated string is $newJsonString"
        $externalStorageProvider = "{`"Type`":`"S3`",`"ExternalStorageKey`":`"$guid`",`"BucketName`":`"$bucketName`",`"Region`":{`"SystemName`":`"$($region.Region)`",`"DisplayName`":`"$($region.Name)`"}}"
        try {
			
			if($isIdColumnInt) {
				#$msmDatabase.ExecuteNonQuery("UPDATE $tableName SET $contentColumnName = NULL, externalStorageProvider = '$externalStorageProvider' WHERE $primaryKeyColumnName = $id")
			} else {
			#	$msmDatabase.ExecuteNonQuery("UPDATE $tableName SET $contentColumnName = NULL, externalStorageProvider = '$externalStorageProvider' WHERE $primaryKeyColumnName = '$id'")
			}
			
			$successCount++
        } catch {
            $failedCount++;
            echo "An exception occured while proccessing $primaryKeyColumnName - {$id}: $_"
        } finally {
            $progress++;
            $percentageComplete = ($progress / $totalItems) * 100
           # Write-Progress -Activity "Move in Progress" -Status "$percentageComplete% Complete:" -PercentComplete $percentageComplete;
        }
    }
    echo "Total items are $totalItemsToImport";
    if ($totalItemsToImport -gt 0) {
        echo "Move completed. Successfully moved $successCount/$totalItems rows to storage, now have $totalItemsToImport rows left to transfer..."
    } else {
     $hasResults = 0;
    }
    }
}
}

# ensure we're elevated
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
if (!$isAdmin) {
    try {
        # we're not running elevated - so try to relaunch as administrator
        echo "Starting elevated PowerShell instance."
        $newProcess = New-Object System.Diagnostics.ProcessStartInfo "PowerShell"
        $newProcess.Arguments = @("-NoProfile","-NoLogo", $myInvocation.MyCommand.Definition, "-containerName `"$containername`" -dbServer `"$dbServer`" -dbName `"$dbName`" -dbUser `"$dbUser`" -dbPassword `"$dbPassword`" -tables `"$tables`"")
        $newProcess.Verb = "runas"
        [System.Diagnostics.Process]::Start($newProcess)
    }
    catch {
        echo "Unable to start elevated PowerShell instance."
    }
    finally {
        # always exit this script either we're now running a separate elevated power shell or we've had an error
        exit
    }
}

[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]"Ssl3,Tls,Tls11,Tls12"

# ensure we have the Microsoft.SqlServer.Smo module installed
$sqlServerModules = Get-Module -ListAvailable -Name SqlServer

if ($sqlServerModules) {
    Import-Module SqlServer
}

[Reflection.Assembly]::LoadWithPartialName("Microsoft.SqlServer.Smo") | Out-Null

if (!$sqlServerModules) {
    try {
        New-Object Microsoft.SqlServer.Management.SMO.Database | Out-Null
    } catch {
        echo "Installing SqlServer module..."
        Install-Module SqlServer -Scope CurrentUser
        Import-Module SqlServer
        [Reflection.Assembly]::LoadWithPartialName("Microsoft.SqlServer.Smo") | Out-Null
    }
}

# ensure we have the AWS CLI installed

# ensure we have the AWSPowerShell module installed
$awsPowerShellModules = Get-Module -ListAvailable -Name AWSPowerShell

if ($awsPowerShellModules) {
    Import-Module AWSPowerShell
}

if (!$awsPowerShellModules) {
    try {
        Set-AWSCredential
    } catch {
        echo "Installing AWSPowerShell module..."
        Install-Module AWSPowerShell -Scope CurrentUser
        Import-Module AWSPowerShell
    }
}

# check if we must use the default profile or the user specified profile as well as if it has a region set
$awsProfile = if (!$awsProfile) {"default"} else {$awsProfile}

if ((Get-AWSCredential -ListProfileDetail | Where-Object {$_.ProfileName -eq $awsProfile}).count -eq 1) {
    Set-AWSCredential -ProfileName $awsProfile # set default region for this session using the profiles region
    Set-DefaultAWSRegion (aws configure get region --profile $awsProfile)
    $region = (Get-DefaultAWSRegion) # set global region for access by functions 

    # ensure a default region has been set using the region found on the profile specified
    if ((Get-DefaultAWSRegion).count -eq 0) {
        echo "Please set a default region on the AWS profile you provided and try again"
        exit
    }

    echo "Using AWS profile: $awsProfile"
    echo "Using AWS region: $($region.Region)"
} else {
    echo "No profile found for $awsProfile, please specify -awsProfile with a valid profile or create the missing profile"
    exit
}

# check if we must create or use an existing bucket and whether or not the existing bucket exists and is valid
if($createBucket) {
    echo "Creating a new bucket named $createBucket..."
    New-S3Bucket -BucketName $createBucket | Out-Null
    $bucketName = $createBucket # set bucketname 
} elseif($bucketName) {
   if ($isMinio -eq 1) {

    if ((Get-S3Bucket -EndpointUrl http://localhost:9000 | Where-Object {$_.BucketName -eq $bucketName}).count -eq 0) {
        echo "Bucket $bucketName not found. Please specify a valid existing bucket name or a new one with -createBucket"
        exit
    }
    }
    else {
  
       if ((Get-S3Bucket | Where-Object {$_.BucketName -eq $bucketName}).count -eq 0) {
        echo "Bucket $bucketName not found. Please specify a valid existing bucket name or a new one with -createBucket"
        exit
    }
    
    }
} else {
    echo "-createBucket or -bucketName must be specified"
    exit
}

# ensure db credentials are specified
if (!$dbServer -or !$dbName -or !$dbUser) {
    echo "-dbServer, -dbName and -dbUser MUST be specified!"
    exit
}

# ensure tables are specified
if(!$tables) {
    echo "Please specify tables to move data to S3 API using -tables table1,table2 table1 and table2 are simply examples."
    exit
}

$server = New-Object Microsoft.SqlServer.Management.SMO.Server(New-Object Microsoft.SqlServer.Management.Common.ServerConnection($dbServer, $dbUser, $dbPassword))
$msmDatabase = New-Object Microsoft.SqlServer.Management.SMO.Database($server, $dbName)

$tableArray = $tables.Split(",")
Foreach ($table in $tableArray) {
    switch($table) {
        "queuedNotification" { Move-DataToAWS -tableName queuedNotification -primaryKeyColumnName queuedNotificationId -contentColumnName content }
        "attachment" { Move-DataToAWS -tableName attachment -primaryKeyColumnName attachmentId -contentColumnName content }
		"note" { Move-DataToAWS -tableName note -primaryKeyColumnName noteIdentifier -contentColumnName content }
		"richTextImage" { Move-DataToAWS -tableName richTextImage -primaryKeyColumnName fileName -contentColumnName content -isIdColumnInt $false }
    }
}
